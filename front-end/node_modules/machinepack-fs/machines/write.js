module.exports = {

  friendlyName: 'Write file from string',
  description: 'Generate a file on the local filesystem using the specified utf8 string as its contents.',

  inputs: {
    string: {
      description: 'Text to write to the file',
      example: 'lots of words, utf8 things you know',
    },
    destination: {
      description: 'Path (relative or absolute) to the file to write.',
      example: '/Users/mikermcneil/.tmp/bar',
      required: true
    },
    force: {
      description: 'overwrite existing file(s)?',
      example: false
    }
  },

  defaultExit: 'success',
  catchallExit: 'error',

  exits: {
    error: {},
    success: {},
    alreadyExists: {
      description: 'Something already exists at the specified path (overwrite by enabling the `force` input)'
    }
  },

  fn: function (inputs, exits) {

    var path = require('path');
    var fsx = require('fs-extra');
    var _ = require('lodash');
    var async = require('async');

    inputs = _.defaults(inputs, {
      force: false,
      dry: false
    });

    // Coerce `string` input into an actual string
    inputs.string = inputs.string || '';

    // In case we ended up here w/ a relative path,
    // resolve it using the process's CWD
    inputs.destination = path.resolve(process.cwd(), inputs.destination);

    // Only override an existing file if `inputs.force` is true
    fsx.exists(inputs.destination, function(exists) {
      if (exists && !inputs.force) {
        return (exits.alreadyExists||exits.error)('Something else already exists at ::' + inputs.destination);
      }

      // Don't actually write the file if this is a dry run.
      if (inputs.dry) return exits.success();

      async.series([
        function deleteExistingFileIfNecessary(exits) {
          if (!exists) return exits();
          return fsx.remove(inputs.destination, exits);
        },
        function writeToDisk(exits) {
          fsx.outputFile(inputs.destination, inputs.string, exits);
        }
      ], function (err){
        if (err) return exits(err);
        return exits();
      });

    });

  }
};

// Generated by CoffeeScript 1.10.0
var deepSort, fs, isArray, isObject, isString, objDeepSort, osenv, replaceTilda, t;

osenv = require('osenv');

fs = require('fs');

t = Object.prototype.toString;

exports.toInt = function(v) {
  return parseInt(v, 10) || 0;
};

exports.toFloat = function(f) {
  return parseFloat(f, 10) || 0;
};

exports.randomInt = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

exports.toBoolean = function(v) {
  return !(v === 'false' || v === '0' || v === 'null' || v === '' || v === 0 || v === null || v === false || v === void 0 || v !== v);
};

exports.isNumber = function(s) {
  return s === s & t.call(s) === '[object Number]';
};

exports.isString = isString = function(s) {
  return t.call(s) === '[object String]';
};

exports.isArray = isArray = function(s) {
  return t.call(s) === '[object Array]';
};

exports.isObject = isObject = function(s) {
  return t.call(s) === '[object Object]';
};

exports.isFunction = function(s) {
  return t.call(s) === '[object Function]';
};

exports.isBoolean = function(s) {
  return t.call(s) === '[object Boolean]';
};

exports.isType = function(s, t) {
  return t.call(s).slice(8, -1) === t;
};

exports.typeOf = function(s) {
  return t.call(s).slice(8, -1);
};

exports.msg = function(n) {
  return msg[config.global.lngDef][n];
};

replaceTilda = function(s) {
  if (s.indexOf('~') === 0) {
    s = s.split('~')[1];
    s = osenv.home() + s;
  }
  return s;
};

exports.configLoad = function(s) {
  var conf, error, error1, key, lConf, ref, val;
  try {
    conf = require(s);
  } catch (error1) {
    error = error1;
    log.error('Load error in "' + s + '"\n', error);
    return {};
  }
  if ((conf.path !== undefined) && (conf.path.localConfig !== undefined) && fs.existsSync(conf.path.localConfig)) {
    lConf = replaceTilda(conf.path.localConfig);
    lConf = require(lConf);
    for (key in lConf) {
      val = lConf[key];
      conf[key] = val;
    }
  }
  ref = conf.path;
  for (key in ref) {
    val = ref[key];
    conf.path[key] = replaceTilda(val);
  }
  return conf;
};

exports.objSort = function(object, sorter) {
  var j, key, keys, len, sortedObj;
  sortedObj = {};
  keys = Object.keys(object);
  keys.sort(function(key1, key2) {
    key1 = key1.toLowerCase();
    key2 = key2.toLowerCase();
    if (key1 < key2) {
      return -1;
    } else if (key1 > key2) {
      return 1;
    } else {
      return 0;
    }
  });
  for (j = 0, len = keys.length; j < len; j++) {
    key = keys[j];
    sortedObj[key] = object[key];
  }
  return sortedObj;
};

exports.objDeepSort = objDeepSort = function(object) {
  var i, item, j, k, key, keys, len, len1, sortedObj;
  if (isObject(object)) {
    sortedObj = {};
    keys = Object.keys(object);
    keys.sort(function(key1, key2) {
      key1 = key1.toLowerCase();
      key2 = key2.toLowerCase();
      if (key1 < key2) {
        return -1;
      } else if (key1 > key2) {
        return 1;
      } else {
        return 0;
      }
    });
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      if (isObject(object[key])) {
        sortedObj[key] = objectDeepSort(object[key]);
      } else {
        sortedObj[key] = object[key];
      }
    }
    return sortedObj;
  } else if (isArray(object)) {
    for (i = k = 0, len1 = object.length; k < len1; i = ++k) {
      item = object[i];
      object[i] = objectDeepSort(item);
    }
  }
  return object;
};

exports.deepSort = deepSort = function(object) {
  var i, item, j, k, key, keys, len, len1, sortedObj;
  if (isObject(object)) {
    sortedObj = {};
    keys = Object.keys(object);
    keys.sort(function(key1, key2) {
      key1 = key1.toLowerCase();
      key2 = key2.toLowerCase();
      if (key1 < key2) {
        return -1;
      } else if (key1 > key2) {
        return 1;
      } else {
        return 0;
      }
    });
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      if (isObject(object[key])) {
        sortedObj[key] = deepSort(object[key]);
      } else {
        sortedObj[key] = object[key];
      }
    }
    return sortedObj;
  } else if (isArray(object)) {
    for (i = k = 0, len1 = object.length; k < len1; i = ++k) {
      item = object[i];
      object[i] = deepSort(item);
    }
    object.sort(function(a, b) {
      var k1, k2;
      k1 = Object.keys(a);
      k2 = Object.keys(b);
      if (k1.length === 0) {
        return -1;
      } else if (k2.length === 0) {
        return 1;
      }
      k1 = k1[0];
      k2 = k2[0];
      if (k1 < k2) {
        return -1;
      } else if (k2 < k1) {
        return 1;
      } else {
        return 0;
      }
    });
  }
  return object;
};

exports.num2str = function num2str(num, len, base){
    base = base || 10;
    var res = num.toString(base).toUpperCase()
        , len
        , i = 0
    ;
    if( res.length < len ){
        len = len - res.length;
        for(i; i<len; i++){
            res = '0' + res;
        }
    } else if( res.length > len ) {
        res = res.slice( 0-len );
    }
    return res;
};

exports.dump = function dump(str){
    var lines
        , i = 0
        , len = str.length
        , lineLen = 16
        , newLine = ''
        , charCode
    ;
    if( !isString(str) ){ return }

    for(i; i<len; i++){
        if( i%lineLen === 0 ){
            newLine = ' ' + num2str( i, 8, 16 ) + '  ';
        } else {
            charCode = str.charCodeAt(i);
            if( i%4 === 0 ){ newLine += ' ' }
            newLine += num2str(charCode, 2, 16) + ' ' ;
            if( (i+1)%lineLen === 0 || i === len ){
                console.info(
                    newLine
                    , str.slice( Math.max(0,i-lineLen+1), Math.min(len, i+1) )
                );
            }
        }
    }
};

exports.require = function(s) {
  var error, error1, r;
  r = {};
  try {
    log.info('Loading app module:', s);
    r = require(s);
  } catch (error1) {
    error = error1;
    log.error;
    console.error('Load error in "' + s + '"\n', error);
    r = error;
  }
  return r;
};

//# sourceMappingURL=tools.js.map
